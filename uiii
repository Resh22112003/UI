Got it! You want to:

Use the response returned from the submitAPI1, submitAPI2, or submitAPI3 functions (from your form submission).

Pass that response to DataTable.jsx so that it can directly use that data instead of fetching it again via fetchFormData().



---

Step-by-Step Solution:

We'll:

1. Store the response data in a global state (using React Context or a state manager like Redux).


2. Pass it to DataTable after navigation.




---

Step 1: Create a context (DataContext.jsx)

import React, { createContext, useState } from 'react';

export const DataContext = createContext();

export function DataProvider({ children }) {
  const [tableData, setTableData] = useState([]);

  return (
    <DataContext.Provider value={{ tableData, setTableData }}>
      {children}
    </DataContext.Provider>
  );
}


---

Step 2: Wrap your App with DataProvider in main.jsx or App.jsx

import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { DataProvider } from './DataContext';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <DataProvider>
      <App />
    </DataProvider>
  </React.StrictMode>
);


---

Step 3: Modify Form.jsx to store response in context and then navigate

Update your Form.jsx:

import { useContext } from 'react';
import { DataContext } from './DataContext';
// ...

const { setTableData } = useContext(DataContext);

// ...
const message = await submitAPI1({ neid, timeRange });
// or API2/API3 depending on conditions

const parsedData = JSON.parse(message); // assuming response is a JSON string
setTableData(parsedData);
navigate('/table');


---

Step 4: Modify DataTable.jsx to use context data instead of fetching

import React, { useContext } from 'react';
import { DataContext } from './DataContext';
import './DataTable.css';

const TABLE_COLUMNS = ['neid', 'timestamp', 'portname', 'description', 'direction', 'kpis', 'location', 'unit'];

function DataTable() {
  const { tableData } = useContext(DataContext);

  const downloadTable = () => {
    if (tableData.length === 0) return;

    const csvRows = [
      TABLE_COLUMNS.join(','),
      ...tableData.map(row =>
        TABLE_COLUMNS.map(col => `"${row[col] || ''}"`).join(',')
      )
    ];

    const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = 'form-data.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="json-table-container">
      <h2>Performance Data Table</h2>
      {tableData.length === 0 ? (
        <p>No Data Available</p>
      ) : (
        <>
          <table className="json-table">
            <thead>
              <tr>
                {TABLE_COLUMNS.map((key) => (
                  <th key={key}>{key.toUpperCase()}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {tableData.map((row, index) => (
                <tr key={index}>
                  {TABLE_COLUMNS.map((col, i) => (
                    <td key={i}>{row[col] || ''}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
          <button className="download-btn" onClick={downloadTable}>
            Download CSV
          </button>
        </>
      )}
    </div>
  );
}

export default DataTable;


---

Final Notes:

This ensures the posted response data is stored once and used in the table.

If your API response is not a JSON string, you may need to change response.text() to response.json() in your API methods.


Let me know if youâ€™d like me to update the API file or add error handling too.

